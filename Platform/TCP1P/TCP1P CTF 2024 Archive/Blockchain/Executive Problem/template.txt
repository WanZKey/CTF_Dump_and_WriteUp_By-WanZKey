sekarang bantu saya mengerjakan CTF Blockchain ini:
Executive Problem
1000Â pts
Author:Â kiinzu
If only we managed to climb high enough, maybe we can dethrone someone?
Start challenge from:Â https://gzcli.1pc.tf/tcp1p-ctf-2024-archive-blockchain-executive-problem
Download Attachment

Informasi url:
Executive Problem
ðŸ“ Blockchain
ðŸŽ¯ TCP1P CTF 2024 Archive
ðŸ‘¥ 1 user
Ports:
56245:8080
Connection:Â Connected
Status:Â running
Challenge started successfully

berikut informasi file dan yang diberikan:
â”Œâ”€â”€(wanz)â”€(wanzkeyã‰¿Hengker-Bwang)-[~/TCP1P/TCP1P CTF 2024 Archive/Blockchain/Executive Problem]
â””â”€$ file executiveproblem_executiveproblem-dist.zip
executiveproblem_executiveproblem-dist.zip: Zip archive data, at least v2.0 to extract, compression method=deflate

â”Œâ”€â”€(wanz)â”€(wanzkeyã‰¿Hengker-Bwang)-[~/TCP1P/TCP1P CTF 2024 Archive/Blockchain/Executive Problem]
â””â”€$ unzip executiveproblem_executiveproblem-dist.zip
Archive:Â  executiveproblem_executiveproblem-dist.zip
Â  inflating: CrainExecutive.sol
Â  inflating: Crain.sol
Â  inflating: Setup.sol

â”Œâ”€â”€(wanz)â”€(wanzkeyã‰¿Hengker-Bwang)-[~/TCP1P/TCP1P CTF 2024 Archive/Blockchain/Executive Problem]
â””â”€$ tree
.
â”œâ”€â”€ CrainExecutive.sol
â”œâ”€â”€ Crain.sol
â”œâ”€â”€ executiveproblem_executiveproblem-dist.zip
â””â”€â”€ Setup.sol

1 directory, 4 files

â”Œâ”€â”€(wanz)â”€(wanzkeyã‰¿Hengker-Bwang)-[~/TCP1P/TCP1P CTF 2024 Archive/Blockchain/Executive Problem]
â””â”€$ cat Setup.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "./Crain.sol";
import "./CrainExecutive.sol";

contract Setup{
Â  Â  CrainExecutive public cexe;
Â  Â  Crain public crain;

Â  Â  constructor() payable{
Â  Â  Â  Â  cexe = new CrainExecutive{value: 50 ether}();
Â  Â  Â  Â  crain = new Crain(payable(address(cexe)));
Â  Â  }

Â  Â  function isSolved() public view returns(bool){
Â  Â  Â  Â  return crain.crain() != address(this);
Â  Â  }

}Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
â”Œâ”€â”€(wanz)â”€(wanzkeyã‰¿Hengker-Bwang)-[~/TCP1P/TCP1P CTF 2024 Archive/Blockchain/Executive Problem]
â””â”€$ cat Crain.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "./CrainExecutive.sol";

contract Crain{
Â  Â  CrainExecutive public ce;
Â  Â  address public crain;

Â  Â  modifier _onlyExecutives(){
Â  Â  Â  Â  require(msg.sender == address(ce), "Only Executives can replace");
Â  Â  Â  Â  _;
Â  Â  }

Â  Â  constructor(address payable _ce) {
Â  Â  Â  Â  ce = CrainExecutive(_ce);
Â  Â  Â  Â  crain = msg.sender;
Â  Â  }


Â  Â  function ascendToCrain(address _successor) public _onlyExecutives{
Â  Â  Â  Â  crain = _successor;
Â  Â  }

Â  Â  receive() external payable { }

}Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
â”Œâ”€â”€(wanz)â”€(wanzkeyã‰¿Hengker-Bwang)-[~/TCP1P/TCP1P CTF 2024 Archive/Blockchain/Executive Problem]
â””â”€$ cat CrainExecutive.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract CrainExecutive{

Â  Â  address public owner;
Â  Â  uint256 public totalSupply;

Â  Â  address[] public Executives;
Â  Â  mapping(address => uint256) public balanceOf;
Â  Â  mapping(address => bool) public permissionToExchange;
Â  Â  mapping(address => bool) public hasTakeBonus;
Â  Â  mapping(address => bool) public isEmployee;
Â  Â  mapping(address => bool) public isManager;
Â  Â  mapping(address => bool) public isExecutive;

Â  Â  modifier _onlyOnePerEmployee(){
Â  Â  Â  Â  require(hasTakeBonus[msg.sender] == false, "Bonus can only be taken once!");
Â  Â  Â  Â  _;
Â  Â  }

Â  Â  modifier _onlyExecutive(){
Â  Â  Â  Â  require(isExecutive[msg.sender] == true, "Only Higher Ups can access!");
Â  Â  Â  Â  _;
Â  Â  }

Â  Â  modifier _onlyManager(){
Â  Â  Â  Â  require(isManager[msg.sender] == true, "Only Higher Ups can access!");
Â  Â  Â  Â  _;
Â  Â  }

Â  Â  modifier _onlyEmployee(){
Â  Â  Â  Â  require(isEmployee[msg.sender] == true, "Only Employee can exchange!");
Â  Â  Â  Â  _;
Â  Â  }

Â  Â  constructor() payable{
Â  Â  Â  Â  owner = msg.sender;
Â  Â  Â  Â  totalSupply = 50 ether;
Â  Â  Â  Â  balanceOf[msg.sender] = 25 ether;
Â  Â  }

Â  Â  function claimStartingBonus() public _onlyOnePerEmployee{
Â  Â  Â  Â  balanceOf[owner] -= 1e18;
Â  Â  Â  Â  balanceOf[msg.sender] += 1e18;
Â  Â  }

Â  Â  function becomeEmployee() public {
Â  Â  Â  Â  isEmployee[msg.sender] = true;
Â  Â  }

Â  Â  function becomeManager() public _onlyEmployee{
Â  Â  Â  Â  require(balanceOf[msg.sender] >= 1 ether, "Must have at least 1 ether");
Â  Â  Â  Â  require(isEmployee[msg.sender] == true, "Only Employee can be promoted");
Â  Â  Â  Â  isManager[msg.sender] = true;
Â  Â  }

Â  Â  function becomeExecutive() public {
Â  Â  Â  Â  require(isEmployee[msg.sender] == true && isManager[msg.sender] == true);
Â  Â  Â  Â  require(balanceOf[msg.sender] >= 5 ether, "Must be that Rich to become an Executive");
Â  Â  Â  Â  isExecutive[msg.sender] = true;
Â  Â  }

Â  Â  function buyCredit() public payable _onlyEmployee{
Â  Â  Â  Â  require(msg.value >= 1 ether, "Minimum is 1 Ether");
Â  Â  Â  Â  uint256 totalBought = msg.value;
Â  Â  Â  Â  balanceOf[msg.sender] += totalBought;
Â  Â  Â  Â  totalSupply += totalBought;
Â  Â  }

Â  Â  function sellCredit(uint256 _amount) public _onlyEmployee{
Â  Â  Â  Â  require(balanceOf[msg.sender] - _amount >= 0, "Not Enough Credit");
Â  Â  Â  Â  uint256 totalSold = _amount;
Â  Â  Â  Â  balanceOf[msg.sender] -= totalSold;
Â  Â  Â  Â  totalSupply -= totalSold;
Â  Â  }

Â  Â  function transfer(address to, uint256 _amount, bytes memory _message) public _onlyExecutive{
Â  Â  Â  Â  require(to != address(0), "Invalid Recipient");
Â  Â  Â  Â  require(balanceOf[msg.sender] - _amount >= 0, "Not enough Credit");
Â  Â  Â  Â  uint256 totalSent = _amount;
Â  Â  Â  Â  balanceOf[msg.sender] -= totalSent;
Â  Â  Â  Â  balanceOf[to] += totalSent;
Â  Â  Â  Â  (bool transfered, ) = payable(to).call{value: _amount}(abi.encodePacked(_message));
Â  Â  Â  Â  require(transfered, "Failed to Transfer Credit!");
Â  Â  }

}Â 
