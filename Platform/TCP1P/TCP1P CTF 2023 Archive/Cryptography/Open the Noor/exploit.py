#!/usr/bin/env python3
"""
Open the Noor - Padding Oracle Attack Solution
TCP1P CTF 2023

Strategy:
1. Get encrypted password from server (IV + CT)
2. Use padding oracle to find intermediate values: I = Dec_K(CT)
3. Craft new IV/blocks such that I XOR new_block = target_plaintext
4. Submit crafted ciphertext to get flag
"""

from pwn import *
from Crypto.Util.Padding import pad

HOST = "gzcli.1pc.tf"
PORT = 52664

def xor_bytes(a, b):
    return bytes(x ^ y for x, y in zip(a, b))

def padding_oracle(conn, ct_hex):
    """Returns True if padding is valid, False otherwise"""
    conn.sendlineafter(b"> ", b"1")
    conn.sendlineafter(b"[?] ", ct_hex.encode())
    resp = conn.recvline()
    return b"Something's wrong" not in resp

def decrypt_block_with_oracle(conn, ct_block):
    """
    Decrypt a single ciphertext block using padding oracle.
    Returns the intermediate value I where PT = I XOR IV
    """
    intermediate = bytearray(16)
    
    for pad_len in range(1, 17):
        # We're looking for byte at position (16 - pad_len)
        pos = 16 - pad_len
        
        # Construct probe IV
        probe_iv = bytearray(16)
        
        # Set known bytes to produce target padding
        for i in range(pos + 1, 16):
            probe_iv[i] = intermediate[i] ^ pad_len
        
        # Try all values for current byte
        found = False
        for val in range(256):
            probe_iv[pos] = val
            
            # Test with oracle
            test_ct = (bytes(probe_iv) + ct_block).hex()
            
            try:
                if padding_oracle(conn, test_ct):
                    # Valid padding! This means:
                    # Dec(ct_block)[pos] XOR probe_iv[pos] = pad_len
                    # So: intermediate[pos] = probe_iv[pos] XOR pad_len
                    intermediate[pos] = val ^ pad_len
                    
                    log.info(f"  Byte {pos:2d}: 0x{intermediate[pos]:02x}")
                    found = True
                    break
            except:
                pass
        
        if not found:
            # Sometimes padding=1 can have multiple valid values
            # Try to handle edge case for last byte
            if pad_len == 1:
                # Try values that could give padding 2, 3, etc.
                for check_pad in [2, 3, 4, 5]:
                    probe_iv[15] = intermediate[15] ^ 1
                    probe_iv[14] = check_pad ^ check_pad  # This gives padding check_pad
                    test_ct = (bytes(probe_iv) + ct_block).hex()
                    if padding_oracle(conn, test_ct):
                        # This confirms intermediate[15] is correct
                        found = True
                        break
            
            if not found:
                log.error(f"  Failed at byte {pos}")
                return None
    
    return bytes(intermediate)

def exploit():
    target = b"nottheflagbutstillcrucialvalidation"
    target_padded = pad(target, 16)
    
    log.info(f"Target: {target.decode()}")
    log.info(f"Padded length: {len(target_padded)} bytes ({len(target_padded)//16} blocks)")
    
    conn = remote(HOST, PORT, level='error')
    
    # Get encrypted password
    log.info("\n[1] Retrieving encrypted password...")
    conn.sendlineafter(b"> ", b"3")
    conn.recvuntil(b"[+] ")
    enc_hex = conn.recvline().strip().decode()
    enc = bytes.fromhex(enc_hex)
    
    iv_orig = enc[:16]
    ct_orig = enc[16:]
    
    log.info(f"Encrypted: {enc_hex[:64]}...")
    log.info(f"CT blocks: {len(ct_orig)//16}")
    
    # We need 3 blocks total for 48 bytes
    num_blocks_needed = 3
    
    # Take first 3 ciphertext blocks (or pad with zeros if less)
    ct_blocks = []
    for i in range(num_blocks_needed):
        if i * 16 < len(ct_orig):
            ct_blocks.append(ct_orig[i*16:(i+1)*16])
        else:
            ct_blocks.append(bytes(16))
    
    # Decrypt each block to get intermediate values
    log.info("\n[2] Performing padding oracle attack...")
    intermediates = []
    
    for i, ct_block in enumerate(ct_blocks):
        log.info(f"\n  Block {i+1}/{num_blocks_needed}:")
        inter = decrypt_block_with_oracle(conn, ct_block)
        
        if inter is None:
            log.error("Decryption failed!")
            conn.close()
            return
        
        intermediates.append(inter)
        log.success(f"  Intermediate: {inter.hex()}")
    
    # Now craft the payload
    # AES-CBC decryption: PT[i] = Dec_K(CT[i]) XOR previous_block
    # 
    # We know:
    # - intermediate[i] = Dec_K(ct_blocks[i]) for each block
    # 
    # We want to create a new ciphertext that decrypts to target_padded:
    # - target[0:16]  = Dec_K(CT_new[0]) XOR IV_new
    # - target[16:32] = Dec_K(CT_new[1]) XOR CT_new[0]  
    # - target[32:48] = Dec_K(CT_new[2]) XOR CT_new[1]
    #
    # Strategy: Keep the CT blocks (they have known intermediates),
    # and adjust the "previous blocks" (IV and CT blocks) to produce target PT
    
    log.info("\n[3] Crafting malicious ciphertext...")
    
    # For block 0: target[0:16] = intermediate[0] XOR IV_new
    # So: IV_new = intermediate[0] XOR target[0:16]
    new_iv = xor_bytes(intermediates[0], target_padded[0:16])
    log.info(f"New IV: {new_iv.hex()}")
    
    # For block 1: target[16:32] = intermediate[1] XOR CT_new[0]
    # So: CT_new[0] = intermediate[1] XOR target[16:32]
    ct_new_0 = xor_bytes(intermediates[1], target_padded[16:32])
    log.info(f"CT block 0 (modified): {ct_new_0.hex()}")
    
    # For block 2: target[32:48] = intermediate[2] XOR CT_new[1]
    # So: CT_new[1] = intermediate[2] XOR target[32:48]
    ct_new_1 = xor_bytes(intermediates[2], target_padded[32:48])
    log.info(f"CT block 1 (modified): {ct_new_1.hex()}")
    
    # We need a dummy third CT block (won't be decrypted as it's the last "previous")
    # Just use the original second block
    ct_new_2 = ct_blocks[2]
    
    # Final payload: IV_new + CT_new[0] + CT_new[1] + CT_new[2]
    # When decrypted:
    # - Dec(CT_new[0]) XOR IV_new = Dec(CT[0]) XOR intermediate[0] XOR target[0:16] 
    #                             = intermediate[0] XOR intermediate[0] XOR target[0:16]
    #                             = target[0:16] ✓
    # Wait, this is wrong...
    
    # Let me reconsider: We decrypted ct_blocks[i] to get intermediate[i]
    # intermediate[i] = Dec_K(ct_blocks[i])
    # 
    # Now we want: target[i*16:(i+1)*16] = Dec_K(some_ct) XOR prev_block
    # 
    # If we use the SAME ct_blocks[i], then:
    # target[i*16:(i+1)*16] = intermediate[i] XOR prev_block_new
    # So: prev_block_new = intermediate[i] XOR target[i*16:(i+1)*16]
    
    # Payload structure: IV_new + ct_blocks[0] + ct_blocks[1] + ct_blocks[2]
    # Decryption:
    # - PT[0] = Dec(ct_blocks[0]) XOR IV_new = intermediate[0] XOR IV_new
    # - PT[1] = Dec(ct_blocks[1]) XOR ct_blocks[0] = intermediate[1] XOR ct_blocks[0]
    # - PT[2] = Dec(ct_blocks[2]) XOR ct_blocks[1] = intermediate[2] XOR ct_blocks[1]
    
    # So we need:
    # - IV_new = intermediate[0] XOR target[0:16] ✓
    # - ct_blocks[0] should be replaced with: intermediate[1] XOR target[16:32]
    # - ct_blocks[1] should be replaced with: intermediate[2] XOR target[32:48]
    
    new_iv = xor_bytes(intermediates[0], target_padded[0:16])
    new_ct_0 = xor_bytes(intermediates[1], target_padded[16:32])
    new_ct_1 = xor_bytes(intermediates[2], target_padded[32:48])
    
    # Final payload: IV + new_ct_0 + new_ct_1 + ct_blocks[2]
    # When this is decrypted:
    # - Block 0: intermediate[0] XOR IV_new = target[0:16] ✓
    # - Block 1: intermediate[1] XOR new_ct_0 = intermediate[1] XOR (intermediate[1] XOR target[16:32]) = target[16:32] ✓
    # - Block 2: intermediate[2] XOR new_ct_1 = intermediate[2] XOR (intermediate[2] XOR target[32:48]) = target[32:48] ✓
    
    payload = new_iv + new_ct_0 + new_ct_1 + ct_blocks[2]
    
    log.info(f"Modified CT[0]: {new_ct_0.hex()}")
    log.info(f"Modified CT[1]: {new_ct_1.hex()}")
    log.info(f"Original CT[2]: {ct_blocks[2].hex()}")
    
    log.info(f"\n[4] Final payload ({len(payload)} bytes):")
    log.info(f"    {payload.hex()}")
    
    # Submit payload
    log.info("\n[5] Submitting payload for login...")
    conn.sendlineafter(b"> ", b"1")
    conn.sendlineafter(b"[?] ", payload.hex().encode())
    
    result = conn.recvall(timeout=3).decode()
    
    print("\n" + "="*70)
    print(result)
    print("="*70)
    
    if "TCP1P{" in result:
        # Extract flag
        flag = result[result.find("TCP1P{"):result.find("}", result.find("TCP1P{"))+1]
        log.success(f"\nFLAG: {flag}")
    
    conn.close()

if __name__ == "__main__":
    context.log_level = 'info'
    exploit()
