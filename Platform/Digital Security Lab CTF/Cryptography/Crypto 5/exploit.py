#!/usr/bin/env python3
import requests
import json
from Crypto.Util.number import long_to_bytes, bytes_to_long

# Target URL
URL = "http://practice-digitalsecuritylab.di.unipi.it:11005/api/dh_exchange/"

# Constants from the server
G = 2
P = 123332382638231725701467272052746646677437210451686403929360967929971726170175522473010422422481335637035691756799160249433550988140577298403502161171408121294152540751727605530438344170959752812965964116010935488849567570589898718274440695293648653888226126185052620716306229882426016512073971282234225856687
C = 64612411667157069503976070918939607708875022270375896159569914279068171237996023267687125585927418267362932620044815107093025867940055155893108177681746956136085002346241007308415060540468449145442966833111022272981874509644086110124172781007706360095880503723087775599509214116527258964018584247604461917771

def xor(a: bytes, b: bytes) -> bytes:
    """XOR two byte strings (mimics server's xor using zip)"""
    return bytes(x ^ y for x, y in zip(a, b))

def exploit():
    print("[*] Starting Diffie-Hellman Attack...")
    print("[*] Vulnerability: Server reuses private key 'b' for both exchanges")
    print()
    
    # ============================================================
    # INSIGHT: We need to get more bytes of the key!
    # The key is long_to_bytes(C^b mod P)
    # 
    # Let's try multiple requests with DIFFERENT known plaintexts
    # to recover more bytes of the key!
    # ============================================================
    
    print("[*] Strategy: Send multiple requests to recover full key")
    print()
    
    # Request 1: Standard request with A = C
    print("[*] Request 1: A = C")
    response1 = requests.post(URL, json={"g": G, "p": P, "A": C}, 
                             headers={"Content-Type": "application/json"})
    data1 = response1.json()
    msg_a1 = bytes.fromhex(data1["msg_a"])
    msg_c = bytes.fromhex(data1["msg_c"])
    B_a1 = data1["B_a"]
    
    print(f"[+] msg_a: {msg_a1.hex()}")
    print(f"[+] B_a: {B_a1}")
    print()
    
    # Recover first 12 bytes
    known_plaintext = b"Hello Alice!"
    key_part1 = xor(msg_a1, known_plaintext)
    print(f"[*] Key bytes [0:12]: {key_part1.hex()}")
    
    # ============================================================
    # NEW STRATEGY: Use B_a to find b, then calculate k_c
    # B_a = G^b mod P
    # If we can find b from B_a, we can calculate k_c = C^b mod P
    # 
    # But wait... discrete log is hard!
    # 
    # BETTER IDEA: Use multiple A values to get more key bytes
    # ============================================================
    
    print()
    print("[*] Trying different approach...")
    print("[*] We need to think about what long_to_bytes(k_c) produces")
    print()
    
    # k_c = C^b mod P is a huge number (up to P)
    # long_to_bytes(k_c) will produce ~128 bytes
    # The server XORs FLAG with first len(FLAG) bytes of long_to_bytes(k_c)
    
    # We have first 12 bytes from the attack
    # For the remaining 9 bytes, we need to think differently
    
    # IDEA: What if we send A = G^12 * C?
    # Then k_a = (G^12 * C)^b = G^(12b) * C^b = G^(12b) * k_c
    # Hmm, this doesn't isolate the next bytes...
    
    # BETTER IDEA: The key is deterministic!
    # k_c = C^b mod P for some specific b
    # long_to_bytes(k_c) produces a specific byte sequence
    # We have the FIRST 12 bytes
    # 
    # The integer k_c, when converted to bytes, has these first 12 bytes
    # We can reconstruct k_c by trying to find what large integer
    # has these first 12 bytes!
    
    print("[*] Key insight: k_c = C^b mod P is deterministic")
    print("[*] We know first 12 bytes of long_to_bytes(k_c)")
    print("[*] We need to find the full integer k_c")
    print()
    
    # The first 12 bytes are: a7645b00d048f029cc2af3d4
    # As an integer: 51805318972484540352745370580
    
    key_int_min = bytes_to_long(key_part1)
    print(f"[*] First 12 bytes as integer: {key_int_min}")
    
    # The full k_c could be:
    # - Exactly this (if k_c < 2^96)
    # - This followed by more bytes (if k_c >= 2^96)
    
    # Since P is ~1024 bits, k_c could be up to ~1024 bits = 128 bytes
    # So k_c is MUCH larger than just 12 bytes
    
    # We need a different approach...
    # Let's try: Send A values that give us specific key relationships
    
    print("[*] Attempting to use math to find remaining bytes...")
    print()
    
    # Actually, let's try a DIFFERENT attack:
    # Send A = 2 (a small number)
    # Then k_a = 2^b mod P
    # This might be easier to work with
    
    print("[*] Request 2: A = 2")
    response2 = requests.post(URL, json={"g": G, "p": P, "A": 2},
                             headers={"Content-Type": "application/json"})
    data2 = response2.json()
    msg_a2 = bytes.fromhex(data2["msg_a"])
    B_a2 = data2["B_a"]
    
    print(f"[+] msg_a with A=2: {msg_a2.hex()}")
    print(f"[+] B_a with A=2: {B_a2}")
    print()
    
    # From this: msg_a2 = "Hello Alice!" XOR long_to_bytes(2^b mod P)
    key_with_A2 = xor(msg_a2, known_plaintext)
    print(f"[*] Key bytes with A=2: {key_with_A2.hex()}")
    print()
    
    # Now we have:
    # B_a1 = B_a2 = G^b mod P (since g=G in both)
    # k_with_C = C^b mod P (first 12 bytes: key_part1)
    # k_with_2 = 2^b mod P (first 12 bytes: key_with_A2)
    
    # Note: B_a1 should equal B_a2 since we use same g and p
    print(f"[*] B_a1 == B_a2: {B_a1 == B_a2}")
    print(f"[*] This confirms b is constant across requests!")
    print()
    
    # Now: k_with_C / k_with_2 = C^b / 2^b = (C/2)^b mod P
    # Or: k_with_C = k_with_2 * (C/2)^b mod P
    
    # Hmm, still need b...
    
    # WAIT! I have a better idea:
    # We can use the LAST BYTE of the flag!
    # We know flag ends with }
    # So msg_c[-1] XOR key[-1] = ord('}')
    # Therefore: key[-1] = msg_c[-1] XOR ord('}')
    
    print("[*] Using known flag format to recover key bytes...")
    flag_end = ord('}')
    key_last_byte = msg_c[-1] ^ flag_end
    print(f"[*] Last key byte (assuming flag ends with '}}': 0x{key_last_byte:02x}")
    print()
    
    # Now let's build the full key:
    # Bytes 0-11: known from key_part1
    # Bytes 12-19: unknown
    # Byte 20: key_last_byte
    
    # We need to brute force bytes 12-19, but with the constraint
    # that the flag must be valid
    
    print("[*] Brute forcing middle bytes with constraints...")
    
    # Try all combinations for bytes 12-19 (8 bytes)
    # That's 256^8 = too many!
    
    # Better: Brute force one byte at a time with validation
    from itertools import product
    
    # Start with what we know
    key_bytes = list(key_part1)
    
    # For bytes 12-19, try to find valid combinations
    # We'll do this intelligently byte-by-byte
    
    for pos in range(12, 20):
        print(f"[*] Finding byte at position {pos}...")
        found = False
        
        for byte_val in range(256):
            # Build test key
            test_key = bytes(key_bytes + [byte_val])
            
            # Decrypt what we have so far
            test_flag = xor(msg_c[:len(test_key)], test_key)
            
            # Check if valid
            try:
                flag_str = test_flag.decode('ascii')
                # Must be TRT{ followed by hex/alphanumeric
                if flag_str.startswith("TRT{") and all(c in "0123456789abcdefABCDEF_{}" for c in flag_str[4:]):
                    # This looks good, but let's also check with the last byte
                    if pos == 19:
                        # Last middle byte - check with known last byte
                        final_test_key = test_key + bytes([key_last_byte])
                        final_flag = xor(msg_c, final_test_key)
                        try:
                            final_str = final_flag.decode('ascii')
                            if final_str.endswith('}') and final_str.startswith('TRT{'):
                                key_bytes.append(byte_val)
                                print(f"    [+] Found: 0x{byte_val:02x} -> {final_str}")
                                found = True
                                break
                        except:
                            pass
                    else:
                        key_bytes.append(byte_val)
                        print(f"    [+] Found: 0x{byte_val:02x} -> {flag_str}")
                        found = True
                        break
            except:
                pass
        
        if not found:
            print(f"    [!] Could not find valid byte at position {pos}")
            return
    
    # Add the last byte
    key_bytes.append(key_last_byte)
    
    final_key = bytes(key_bytes)
    final_flag = xor(msg_c, final_key)
    
    print()
    print("="*60)
    print("[+] FINAL FLAG:")
    print(f"[+] {final_flag.decode('utf-8')}")
    print("="*60)
    print()
    print(f"[*] Full key: {final_key.hex()}")

if __name__ == "__main__":
    try:
        exploit()
    except Exception as e:
        print(f"[-] Error: {e}")
        import traceback
        traceback.print_exc()
